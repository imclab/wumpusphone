diff -Naur asterisk-1.8.0/main/dsp.c asterisk-1.8.0-coins/main/dsp.c
--- asterisk-1.8.0/main/dsp.c	2010-06-07 13:34:45.000000000 -0400
+++ asterisk-1.8.0-coins/main/dsp.c	2010-11-18 00:31:26.000000000 -0500
@@ -19,6 +19,15 @@
  * at the top of the source tree.
  */
 
+/*
+ * This version is klugishly modified by Alex Fink, 2010, to recognise
+ * the US 1700 & 2200 Hz coin tone as if it were a DTMF tone.
+ *
+ * Various things below suggest that a 33ms tone with 33ms separations 
+ * might be too short to be recognised, but it seems to work okay.
+ * Does DTMF_GSIZE matter?
+ */
+
 /*! \file
  *
  * \brief Convenience Signal Processing routines
@@ -156,6 +165,7 @@
 
 #define DTMF_THRESHOLD		8.0e7
 #define FAX_THRESHOLD		8.0e7
+#define COIN_THRESHOLD		8.0e7
 #define FAX_2ND_HARMONIC	2.0     /* 4dB */
 #define DTMF_NORMAL_TWIST	6.3     /* 8dB */
 #ifdef	RADIO_RELAX
@@ -168,6 +178,7 @@
 #define DTMF_2ND_HARMONIC_ROW       (relax ? 1.7 : 2.5)     /* 4dB normal */
 #define DTMF_2ND_HARMONIC_COL	63.1    /* 18dB */
 #define DTMF_TO_TOTAL_ENERGY	42.0
+#define COIN_TO_TOTAL_ENERGY	42.0
 
 #define BELL_MF_THRESHOLD	1.6e9
 #define BELL_MF_TWIST		4.0     /* 6dB */
@@ -256,6 +267,8 @@
 {
 	goertzel_state_t row_out[4];
 	goertzel_state_t col_out[4];
+	goertzel_state_t coin_low_out;
+	goertzel_state_t coin_high_out;
 	int hits_to_begin;		/* How many successive hits needed to consider begin of a digit */
 	int misses_to_end;		/* How many successive misses needed to consider end of a digit */
 	int hits;			/* How many successive hits we have seen already */
@@ -296,10 +309,13 @@
 static const float dtmf_col[] = {
 	1209.0, 1336.0, 1477.0, 1633.0
 };
+static const float coin_low = 1700.0;
+static const float coin_high = 2200.0;
 static const float mf_tones[] = {
 	700.0, 900.0, 1100.0, 1300.0, 1500.0, 1700.0
 };
 static const char dtmf_positions[] = "123A" "456B" "789C" "*0#D";
+static const char coin_char = '$';
 static const char bell_mf_positions[] = "1247C-358A--69*---0B----#";
 static int thresholds[THRESHOLD_MAX];
 
@@ -488,6 +504,8 @@
 		goertzel_init(&s->col_out[i], dtmf_col[i], DTMF_GSIZE);
 		s->energy = 0.0;
 	}
+  goertzel_init(&s->coin_low_out, coin_low, DTMF_GSIZE);
+  goertzel_init(&s->coin_high_out, coin_high, DTMF_GSIZE);  
 	s->current_sample = 0;
 	s->hits = 0;
 	s->misses = 0;
@@ -642,6 +660,8 @@
 {
 	float row_energy[4];
 	float col_energy[4];
+  float coin_low_energy;
+  float coin_high_energy;
 	float famp;
 	int i;
 	int j;
@@ -680,6 +700,8 @@
 			goertzel_sample(s->td.dtmf.col_out + 2, amp[j]);
 			goertzel_sample(s->td.dtmf.row_out + 3, amp[j]);
 			goertzel_sample(s->td.dtmf.col_out + 3, amp[j]);
+			goertzel_sample(&s->td.dtmf.coin_low_out, amp[j]);
+			goertzel_sample(&s->td.dtmf.coin_high_out, amp[j]);
 		}
 		s->td.dtmf.current_sample += (limit - sample);
 		if (s->td.dtmf.current_sample < DTMF_GSIZE) {
@@ -701,6 +723,22 @@
 			}
 		}
 		hit = 0;
+    /* Check for the coin: test if it's past threshold and 
+       it beats all the DTMF frequency peaks.  (No twist test.) */
+    coin_low_energy = goertzel_result (&s->td.dtmf.coin_low_out);
+    coin_high_energy = goertzel_result (&s->td.dtmf.coin_high_out);
+    if (coin_low_energy >= COIN_THRESHOLD &&
+        coin_high_energy >= COIN_THRESHOLD &&
+        coin_low_energy > row_energy[best_row] &&
+        coin_high_energy > row_energy[best_row] &&
+        coin_low_energy > col_energy[best_col] &&
+        coin_high_energy > col_energy[best_col]) {
+			/* fraction of total energy test */
+			if ((coin_low_energy + coin_high_energy) > COIN_TO_TOTAL_ENERGY * s->td.dtmf.energy) {
+				/* Got a hit */
+				hit = coin_char;
+			}
+    }
 		/* Basic signal level test and the twist test */
 		if (row_energy[best_row] >= DTMF_THRESHOLD && 
 		    col_energy[best_col] >= DTMF_THRESHOLD &&
@@ -774,6 +812,8 @@
 			goertzel_reset(&s->td.dtmf.row_out[i]);
 			goertzel_reset(&s->td.dtmf.col_out[i]);
 		}
+    goertzel_reset(&s->td.dtmf.coin_low_out);
+    goertzel_reset(&s->td.dtmf.coin_high_out);
 		s->td.dtmf.energy = 0.0;
 		s->td.dtmf.current_sample = 0;
 	}
